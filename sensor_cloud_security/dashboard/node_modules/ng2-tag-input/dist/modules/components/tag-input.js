var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Component, forwardRef, Input, Output, EventEmitter, Renderer, ViewChild, ViewChildren, ContentChildren, ContentChild, TemplateRef, animate, trigger, style, transition, keyframes, state } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import * as constants from './helpers/constants';
import listen from './helpers/listen';
import { TagInputAccessor, TagModel } from './helpers/accessor';
import { TagInputForm } from './tag-input-form/tag-input-form.component';
import { TagInputDropdown } from './dropdown/tag-input-dropdown.component';
import { TagComponent } from './tag/tag.component';
import 'rxjs/add/operator/debounceTime';
export var TagInputComponent = (function (_super) {
    __extends(TagInputComponent, _super);
    function TagInputComponent(renderer) {
        _super.call(this);
        this.renderer = renderer;
        this.separatorKeys = [];
        this.placeholder = constants.PLACEHOLDER;
        this.secondaryPlaceholder = constants.SECONDARY_PLACEHOLDER;
        this.maxItems = undefined;
        this.readonly = undefined;
        this.transform = function (item) { return item; };
        this.validators = [];
        this.onlyFromAutocomplete = false;
        this.errorMessages = {};
        this.theme = 'default';
        this.onTextChangeDebounce = 250;
        this.pasteSplitPattern = ',';
        this.blinkIfDupe = true;
        this.removable = true;
        this.editable = false;
        this.onAdd = new EventEmitter();
        this.onRemove = new EventEmitter();
        this.onSelect = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onTextChange = new EventEmitter();
        this.onPaste = new EventEmitter();
        this.onValidationError = new EventEmitter();
        this.onTagEdited = new EventEmitter();
        this.listeners = (_a = {},
            _a[constants.KEYDOWN] = [],
            _a[constants.KEYUP] = [],
            _a.change = [],
            _a
        );
        var _a;
    }
    TagInputComponent.prototype.removeItem = function (item) {
        var _this = this;
        this.items = this.items.filter(function (_item) { return _item !== _this.findItem(_this.getTagValue(item)); });
        if (this.selectedTag && this.getTagValue(this.selectedTag) === this.getTagValue(item)) {
            this.selectedTag = undefined;
        }
        this.focus(true);
        this.onRemove.emit(item);
    };
    TagInputComponent.prototype.addItem = function (isFromAutocomplete) {
        if (isFromAutocomplete === void 0) { isFromAutocomplete = false; }
        var item = this.setInputValue(this.inputForm.value.value);
        if (!this.inputForm.form.valid) {
            return;
        }
        if (this.isTagValid(item, isFromAutocomplete)) {
            this.appendNewTag(item);
        }
        else {
            this.onValidationError.emit(item);
        }
        this.setInputValue('');
        this.focus(true);
    };
    TagInputComponent.prototype.isTagValid = function (value, isFromAutocomplete) {
        if (isFromAutocomplete === void 0) { isFromAutocomplete = false; }
        var selectedItem = this.dropdown ? this.dropdown.selectedItem : undefined;
        if (selectedItem && !isFromAutocomplete) {
            return;
        }
        var dupe = this.findItem(value);
        if (!!dupe && this.blinkIfDupe) {
            var item = this.tags.find(function (item) { return item.model === dupe; });
            item.blink();
        }
        return !dupe && !this.maxItemsReached &&
            ((isFromAutocomplete && this.onlyFromAutocomplete) || !this.onlyFromAutocomplete);
    };
    TagInputComponent.prototype.appendNewTag = function (item) {
        var newTag = new TagModel(item, item);
        this.items = this.items.concat([newTag]);
        this.onAdd.emit(newTag);
    };
    TagInputComponent.prototype.selectItem = function (item) {
        if (this.readonly || !item || item === this.selectedTag) {
            return;
        }
        this.selectedTag = item;
        this.onSelect.emit(item);
    };
    TagInputComponent.prototype.findItem = function (value) {
        return this.items.find(function (item) { return item.value === value; });
    };
    TagInputComponent.prototype.fireEvents = function (eventName, $event) {
        var _this = this;
        this.listeners[eventName].forEach(function (listener) { return listener.call(_this, $event); });
    };
    TagInputComponent.prototype.handleKeydown = function (data) {
        var event = data.event;
        var key = event.keyCode || event.which;
        switch (constants.KEY_PRESS_ACTIONS[key]) {
            case constants.ACTIONS_KEYS.DELETE:
                if (this.selectedTag && this.removable) {
                    this.removeItem(this.selectedTag);
                }
                break;
            case constants.ACTIONS_KEYS.SWITCH_PREV:
                this.switchPrev(data.model);
                break;
            case constants.ACTIONS_KEYS.SWITCH_NEXT:
                this.switchNext(data.model);
                break;
            case constants.ACTIONS_KEYS.TAB:
                this.switchNext(data.model);
                break;
            default:
                return;
        }
        event.preventDefault();
    };
    TagInputComponent.prototype.setInputValue = function (value) {
        var item = value ? this.transform(value) : '';
        var control = this.getControl();
        control.setValue(item);
        return item;
    };
    TagInputComponent.prototype.getControl = function () {
        return this.inputForm.value;
    };
    TagInputComponent.prototype.focus = function (applyFocus) {
        if (applyFocus === void 0) { applyFocus = false; }
        if (this.readonly) {
            return;
        }
        if (this.dropdown) {
            this.dropdown.show();
        }
        this.selectedTag = undefined;
        this.onFocus.emit(this.inputForm.value.value);
        if (applyFocus) {
            this.inputForm.focus();
        }
    };
    TagInputComponent.prototype.blur = function () {
        this.onBlur.emit(this.inputForm.value.value);
    };
    TagInputComponent.prototype.hasErrors = function () {
        return this.inputForm && this.inputForm.hasErrors() ? true : false;
    };
    TagInputComponent.prototype.isInputFocused = function () {
        return this.inputForm && this.inputForm.isInputFocused() ? true : false;
    };
    TagInputComponent.prototype.hasCustomTemplate = function () {
        var template = this.templates ? this.templates.first : undefined;
        var menuTemplate = this.dropdown && this.dropdown.templates ? this.dropdown.templates.first : undefined;
        return template && template !== menuTemplate;
    };
    TagInputComponent.prototype.switchNext = function (item) {
        if (this.tags.last.model === item) {
            this.focus(true);
            return;
        }
        var tags = this.tags.toArray();
        var tagIndex = tags.findIndex(function (tag) { return tag.model === item; });
        var tag = tags[tagIndex + 1];
        tag.select.call(tag);
    };
    TagInputComponent.prototype.switchPrev = function (item) {
        if (this.tags.first.model !== item) {
            var tags = this.tags.toArray();
            var tagIndex = tags.findIndex(function (tag) { return tag.model === item; });
            var tag = tags[tagIndex - 1];
            tag.select.call(tag);
        }
    };
    Object.defineProperty(TagInputComponent.prototype, "maxItemsReached", {
        get: function () {
            return this.maxItems !== undefined && this.items.length >= this.maxItems;
        },
        enumerable: true,
        configurable: true
    });
    TagInputComponent.prototype.getTagValue = function (item) {
        return item ? item.value : undefined;
    };
    TagInputComponent.prototype.onPasteCallback = function (data) {
        var _this = this;
        var text = data.clipboardData.getData('text/plain');
        text.split(this.pasteSplitPattern)
            .map(function (item) { return new TagModel(item, item); })
            .forEach(function (item) {
            var value = _this.transform(_this.getTagValue(item));
            if (_this.isTagValid(value)) {
                _this.appendNewTag(value);
            }
        });
        this.onPaste.emit(text);
        setTimeout(function () { return _this.setInputValue(''); }, 0);
    };
    TagInputComponent.prototype.ngOnInit = function () {
        var _this = this;
        listen.call(this, constants.KEYDOWN, function ($event) {
            var itemsLength = _this.items.length, inputValue = _this.inputForm.value.value, isCorrectKey = $event.keyCode === 37 || $event.keyCode === 8;
            if (isCorrectKey && !inputValue && itemsLength) {
                _this.tags.last.select.call(_this.tags.last);
            }
        });
        listen.call(this, constants.KEYDOWN, function ($event) {
            if (_this.separatorKeys.indexOf($event.keyCode) >= 0) {
                $event.preventDefault();
                _this.addItem();
            }
        }, this.separatorKeys.length > 0);
        var maxItemsReached = this.maxItems !== undefined && this.items.length > this.maxItems;
        if (maxItemsReached) {
            this.maxItems = this.items.length;
            console.warn(constants.MAX_ITEMS_WARNING);
        }
    };
    TagInputComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.inputForm.onKeydown.subscribe(function (event) {
            _this.fireEvents('keydown', event);
        });
        if (this.onTextChange.observers.length) {
            this.inputForm.form.valueChanges
                .debounceTime(this.onTextChangeDebounce)
                .subscribe(function () {
                var value = _this.inputForm.value.value;
                _this.onTextChange.emit(value);
            });
        }
        if (this.clearOnBlur || this.addOnBlur) {
            this.inputForm
                .onBlur
                .subscribe(function () {
                if (_this.addOnBlur) {
                    _this.addItem();
                }
                _this.setInputValue('');
            });
        }
        if (this.addOnPaste) {
            var input = this.inputForm.input.nativeElement;
            this.renderer.listen(input, 'paste', this.onPasteCallback.bind(this));
        }
        if (this.hideForm) {
            this.inputForm.destroy();
        }
    };
    TagInputComponent.decorators = [
        { type: Component, args: [{
                    selector: 'tag-input',
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return TagInputComponent; }),
                            multi: true
                        }],
                    styleUrls: ['./tag-input.style.scss'],
                    templateUrl: './tag-input.template.html',
                    animations: [
                        trigger('flyInOut', [
                            state('in', style({ transform: 'translateX(0)' })),
                            transition(':enter', [
                                animate(250, keyframes([
                                    style({ opacity: 0, offset: 0, transform: 'translate(0px, 20px)' }),
                                    style({ opacity: 0.3, offset: 0.3, transform: 'translate(0px, -10px)' }),
                                    style({ opacity: 0.5, offset: 0.5, transform: 'translate(0px, 0px)' }),
                                    style({ opacity: 0.75, offset: 0.75, transform: 'translate(0px, 5px)' }),
                                    style({ opacity: 1, offset: 1, transform: 'translate(0px, 0px)' })
                                ]))
                            ]),
                            transition(':leave', [
                                animate(150, keyframes([
                                    style({ opacity: 1, transform: 'translateX(0)', offset: 0 }),
                                    style({ opacity: 1, transform: 'translateX(-15px)', offset: 0.7 }),
                                    style({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })
                                ]))
                            ])
                        ])
                    ]
                },] },
    ];
    TagInputComponent.ctorParameters = function () { return [
        { type: Renderer, },
    ]; };
    TagInputComponent.propDecorators = {
        'separatorKeys': [{ type: Input },],
        'placeholder': [{ type: Input },],
        'secondaryPlaceholder': [{ type: Input },],
        'maxItems': [{ type: Input },],
        'readonly': [{ type: Input },],
        'transform': [{ type: Input },],
        'validators': [{ type: Input },],
        'onlyFromAutocomplete': [{ type: Input },],
        'errorMessages': [{ type: Input },],
        'theme': [{ type: Input },],
        'onTextChangeDebounce': [{ type: Input },],
        'inputId': [{ type: Input },],
        'inputClass': [{ type: Input },],
        'clearOnBlur': [{ type: Input },],
        'hideForm': [{ type: Input },],
        'addOnBlur': [{ type: Input },],
        'addOnPaste': [{ type: Input },],
        'pasteSplitPattern': [{ type: Input },],
        'blinkIfDupe': [{ type: Input },],
        'removable': [{ type: Input },],
        'editable': [{ type: Input },],
        'onAdd': [{ type: Output },],
        'onRemove': [{ type: Output },],
        'onSelect': [{ type: Output },],
        'onFocus': [{ type: Output },],
        'onBlur': [{ type: Output },],
        'onTextChange': [{ type: Output },],
        'onPaste': [{ type: Output },],
        'onValidationError': [{ type: Output },],
        'onTagEdited': [{ type: Output },],
        'dropdown': [{ type: ContentChild, args: [TagInputDropdown,] },],
        'templates': [{ type: ContentChildren, args: [TemplateRef, { descendants: false },] },],
        'inputForm': [{ type: ViewChild, args: [TagInputForm,] },],
        'tags': [{ type: ViewChildren, args: [TagComponent,] },],
    };
    return TagInputComponent;
}(TagInputAccessor));
//# sourceMappingURL=tag-input.js.map